## Why Sparkly Needs PyLucene

At the heart of Sparkly are Lucene and Spark. The Lucene library allows us to quickly perform information retrieval (IR) style search, that is, find tuple pairs with high BM25 similarity score. Spark allows us to quickly perform this search for large tables in a distributed and parallel fashion. 

However, Lucene is written in Java, while the rest of Sparkly is written in Python, to take advantage of many other Python packages. To bridge this Java-Python gap, we use the well-known package PyLucene. 

Briefly, Python has a C-extension API. This allows programmers to write C, compile it to a library and then call that C library from a Python program. This is how numpy, scipy, pytorch, and many other Python libraries achieve good performance. Java has the Java Native Interface (JNI). This allows C code to start a JVM and call Java code which runs in the JVM. Finally, JCC can take Java code, automatically figures out how to use it in a C program and then creates a C-extension that can be called from a Python program.  

So Sparkly uses PyLucene to call Java-based Lucene as follows. The Python code of Sparkly will call some C libraries (via the C-extension API of Python). These C libraries in turn will start JVMs via the JNI, and these JVMs in turn will run Java-based Lucene. The C libraries mentioned above are created by calling JCC and giving it the Java-based Lucene. 

(Note: JCC technically uses C++ but it is compiled so that the ABI (application binary interface) is compatible with C, so to any outside program imported the compiled library it looks like a C library. In other words, the source code generated by JCC is C++, but to any program linking to the compiled library it looks like a C library.)

